Some Insights on COM and WRL from a C++ Viewpoint
blame for errors in this doc: Dave Remba

The main difficulty in using WRL/COM etc., 
is that it requires you to 
understand what you are doing - 
and that requires *thinking*
 - ow, my head hurts.

(the information below may be gross simplifications, but may help to understand what's going on)

COM is built on the notion of treating a C++ abstract base class as
an interface.  To implement a COM interface, you 
inherit from the abstract base class (the interface).  
The base classes at the root level, are "IUnknown" for Win32, 
and "IInspectable" for WinRT - EVERYTHING inherits from these.

At runtime the methods are accessed by using the "vtable" - the table
of virtual functions generated by the compiler.
This means a consumer of COM need only have a) a pointer to the
class instance (cast as the interface base class), and a definition
of the interface base class.  Then calls are made in the usual C syntax:
ptr->method();

Most of the time you will generate a DLL for components.
A Media Foundation Extension is created when your class inherits
from IMediaExtension.

You can create COM components that are usable from WinRT
using a template library called WRL; for example:

       class CSink
            : public Microsoft::WRL::RuntimeClass<
            Microsoft::WRL::RuntimeClassFlags< Microsoft::WRL::RuntimeClassType::WinRtClassicComMix >,
            Windows::Media::IMediaExtension,
            IMFMediaSink,
            IMFClockStateSink,
            Microsoft::WRL::FtmBase
            >

As noted above, the base classes like IMediaExtension, each inherit from IInspectable.
You also have to provide the RuntimeClassType into the RuntimeClassFlags template.

Here the derived concrete class CSink inherits from several base classes which
are abstract (they are interfaces): IMediaExtension, ... FtmBase
Since these are all pure virtuals in the base abstract classes,
you must implement them, for example:

            // IMediaExtension
            IFACEMETHODIMP SetProperties(ABI::Windows::Foundation::Collections::IPropertySet *pConfiguration)
            {
				...

Usually the interface implementations are put into DLLs
that are linked at runtime to the Win32 exe or WinRT app.
A GUID uniquely identifies the name & version of a DLL
and the interface in both OS flavors, but with WRL
you won't need to deal much with GUIDs.

Casting tips - relevant to WRL/COM:
from http://msdn.microsoft.com/en-us/library/windows/apps/hh755802.aspx

    ABI types live in headers in the Windows SDK. 
    Conveniently, the headers are named after the namespaces�for example, windows.storage.h.

    ABI types live in a special namespace ABI�for example, ABI::Windows::Storage::Streams::IBuffer*.

    Conversions between a Visual C++ component extensions interface type and its 
    equivalent ABI type are always safe�that is, IBuffer^ to ABI::IBuffer*.

    A Visual C++ component extensions runtime class should always be converted to 
    IInspectable* or its default interface, if that is known.

    After you convert to ABI types, you own the lifetime of the type and must 
    follow the COM rules. 
    We recommend that you use WRL::ComPtr to simplify lifetime management of ABI pointers.

At runtime one of the problems the system has to deal with is
locating the DLL for dynamic linking:
On Win32 the system registry is used to look up a DLL from the name.
On WinRT the DLL is included in the app package, so the registry is not used,
and no file system search at runtime is needed.
If there is a reference to the DLL project, then you do not have to add the extension to the
app package manifest.

QueryInterface instantiates the class, and verifies that the class instance does
indeed provide the requested interface using GUID for verification.
We don't need to call QI if we are using WRL, since
WRL provides smart COM pointers, as ComPtr<YourInterfaceclass>
that do this, AddRef, Release, and new/delete for you.

IDL can be used to generate a header file for the interface (recall that's an abstract base class), 
and also the GUID in a generated .cpp file, and optionally remote call
information for client/server uses in another C++ file.

The idea with IDL, is that besides C/C++, other languages and
runtime systems (like .NET) could read the IDL at runtime and
generate language bindings; e.g. Java to C++.  If we didn't
care about other languages, we could force the everyone to
use C/C++ header files only.

With WRL, you can mostly forget and ignore IDL, except for when you create 
a system extension, like a Media Extension.  Then you just
need to declare that it is a "runtimeclass" and uses a system
extension interface, like this:

import "Windows.Media.idl";

namespace CaptureMediaSink
{
    [version(1.0), activatable(1.0)]
    runtimeclass CaptureSink
    {
        [default] interface Windows.Media.IMediaExtension;
    }
}

Note that the IDL namespace must match the C++ namespace, as in:
ABI::CaptureMediaSink.

Namespaces matter, and in WRL, a "module" is a
namespace and must be unique.  Also, WinRT requires a base
namespace of "ABI", so you have ABI::YourNamespace::YourInterfaceClass.
For non-WinRT COM the ABI base namespace is not needed.

If you get the error, "module is already initialized" at runtime,
try recompiling with this cpp defined: __WRL_DISABLE_STATIC_INITIALIZE_

To use a COM or WinRT component with WRL, you include the header
file for the interface, either from the system <>, or from your
own code.  Then using WRL, you obtain a smart
pointer to the interface ComPtr<InterfaceClass>,
and then call a macro "MakeAndInitialize<InterfaceClass>"

MakeAndInitialize<myClass> will call myClass::RuntimeClassInitialize()
Args passed in MakeAndInitialize will be passed into RuntimeClassInitialize.

If you also follow the WinRT ABI rules, then your class becomes a component usable from
other languages, and also usable from WinRT calls as "extensions"
(think of extensions as plug-ins).
The compiler will happily inform you when you break
a WinRT ABI rule as soon as it sees a ^

There is a lot of template metaprogramming in WRL, so to debug,
read the errors on the compiler output carefully, and
don't be hesitant to read the WRL source code - you will
have to anyway to solve errors.

COM components used to require code in dllmain.cpp
With WRL, the practice is to simply use the generated module.cpp/.h
file from the DLL WinRT template.  You don't need to modify
anything in it, but it has to be compiled into your DLL;
and you do NOT need to write a dllmain.cpp file.

WRL makes using COM more modern.  You do not generally have to 
call QI, or write or generate IDL (.idl) or DLL export files (.def)
Unfortunately the MSDN docs have a mix of COM styles
using both ATL for Win32, and WRL, mixes of the two,
and older examples from Win 8.0 etc.  This means
sometimes you see IDL or def files or package extensions when
you don't need them, and/or if found they will break things.
Also, because WRL uses some heavy duty template metaprogramming,
it is touchy and complex, especially MakeAndInitialize<>


A note about pch files:  

precompiled headers are optional, 
and make compilation much faster.  The main limitation is that
Visual C++ can only use ONE pch file per project,
so if you have a big project and a single pch causes
conflicts, then you either have the choice of

a) breaking the big project into smaller one
b) not using pch

There may be a way to use several pch with differing names
by changing settings in the project per subgroup, but this
seeems complex and error-prone.

Since a DLL component compiles separately, it is OK to
use pch, and it won't affect any other projects.

To set up pch for a project:
  Create an empty file pch.cpp and have it include
  pch.h; and the project properites FOR ONLY THIS FILE
  to CREATE PCH.
  For ALL other files in the project, #include pch.h
  at the top of the file, and leave the project propertes
  at the default: USE PCH

Generally you only want to put system includes into the pch.h;
for Media Foundation example:

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN  // Exclude rarely-used stuff from Windows headers
#include <windows.h>

// start of headers used in this project:

#include <mfapi.h>
#include <mfidl.h>

#include <mfobjects.h>
#include <mfreadwrite.h>
#include <mferror.h>

#include <collection.h>

[end]

