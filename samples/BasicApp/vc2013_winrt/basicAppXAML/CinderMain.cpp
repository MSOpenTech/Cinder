// nb. this file was generated by the Windows 8.1 Store XAML template as DirectXPage, then modified for Cinder

// pch off
// #include "pch.h"
#include <wrl.h>
#include <wrl/client.h>
#include <d3d11_2.h>
#include <d2d1_2.h>
#include <d2d1effects_1.h>
#include <dwrite_2.h>
#include <wincodec.h>
#include <DirectXColors.h>
#include <DirectXMath.h>
#include <memory>
#include <agile.h>
#include <concrt.h>
#include <collection.h>
#include "App.xaml.h"


#include "CinderMain.h"
#include "Common\DirectXHelper.h"

#include "Common\StepTimer.h"
#include "Common\DeviceResources.h"

extern cinder::app::CinderMain *app;

using namespace basicAppXAML;
using namespace Windows::Foundation;
using namespace Windows::System::Threading;
using namespace Concurrency;

namespace DX {
    // This internal class relays DeviceLost and DeviceRestored events from 
    // class DeviceResources to class CinderMain, so that CinderMain
    // need not inherit from IDeviceNotify.
    class DeviceRelay : public DX::IDeviceNotify
    {
    public:
        static void RegisterDeviceNotify(const std::shared_ptr<DX::DeviceResources>& deviceResources,
            DX::DeviceRelay &relay )
        {
            deviceResources->RegisterDeviceNotify(&relay);
        }

        // relay events to CinderMain
        virtual void OnDeviceLost()     {   ::app->OnDeviceLost();      }
        virtual void OnDeviceRestored() {   ::app->OnDeviceRestored();  } 
    };

    // singleton, as is ::app
    static DeviceRelay deviceRelay;
}


namespace cinder {
    namespace app {

        // Loads and initializes application assets when the application is loaded.
        void CinderMain::setup(const std::shared_ptr<DX::DeviceResources>& deviceResources)
        {
            m_deviceResources = deviceResources;

            // Register to be notified if the Device is lost or recreated
            DX::deviceRelay.RegisterDeviceNotify(m_deviceResources, DX::deviceRelay);

            // call the app's content initialization.
            setup();

            // optional: frames per second renderer (see SampleFpsTextRenderer in the XAML template)
            // m_fpsTextRenderer = std::unique_ptr<SampleFpsTextRenderer>(new SampleFpsTextRenderer(m_deviceResources));

            // timer for steady and controllable drawing rate (distinct from the frame rate)
            m_timer = new DX::StepTimer;
            // optional: change the timer settings if you want something other than the default variable timestep mode.
            // e.g. for 60 FPS fixed timestep update logic, call:
            //
            // m_timer->SetFixedTimeStep(true);
            // m_timer->SetTargetElapsedSeconds(1.0 / 60);
            //

            // create Cinder renderer for DirectX
            //  nb. Cinder will perform shader & lighting setup, and drawing via dx::
            //  initialization & device management is handled by the XAML framework
            ren = new cinder::app::AppImplMswRendererDx(nullptr, nullptr);

        }

        CinderMain::~CinderMain()
        {
            // Deregister device notification
            m_deviceResources->RegisterDeviceNotify(nullptr);

            delete ren;
            delete m_timer;
        }

        // Updates application state when the window size changes (e.g. device orientation change)
        void CinderMain::CreateWindowSizeDependentResources()
        {
            // optional: add call to the size-dependent initialization of your app's content.
        }

        void CinderMain::StartRenderLoop()
        {
            // If the animation render loop is already running then do not start another thread.
            if (m_renderLoopWorker != nullptr && m_renderLoopWorker->Status == AsyncStatus::Started)
            {
                return;
            }

            // Create a task that will be run on a background thread.
            auto workItemHandler = ref new WorkItemHandler([this](IAsyncAction ^ action)
            {
                // Calculate the updated frame and render once per vertical blanking interval.
                while (action->Status == AsyncStatus::Started)
                {
                    critical_section::scoped_lock lock(m_criticalSection);
                    Update();
                    if (Render())
                    {
                        m_deviceResources->Present();
                    }
                }
            });

            // Run task on a dedicated high priority background thread.
            m_renderLoopWorker = ThreadPool::RunAsync(workItemHandler, WorkItemPriority::High, WorkItemOptions::TimeSliced);
        }

        void CinderMain::StopRenderLoop()
        {
            m_renderLoopWorker->Cancel();
        }

        // Updates the application state once per frame.
        void CinderMain::Update()
        {
            ProcessInput();

            // Update scene objects.
            // nb. this is a C++ 11 lambda function using the instance of DX::StepTimer
            m_timer->Tick([&]()
            {
                // TODO: Replace this with your app's content update functions.
                // call to overloaded Cinder update()
                update();

                // optional: if you are using the frame rate display
                // m_fpsTextRenderer->Update(m_timer);
            });
        }

        // Process all input from the user before updating game state
        void CinderMain::ProcessInput()
        {
            // optional: add per frame input handling here.
        }

        // Renders the current frame according to the current application state.
        // Returns true if the frame was rendered and is ready to be displayed.
        bool CinderMain::Render()
        {
            // Don't try to render anything before the first Update.
            if (m_timer->GetFrameCount() == 0)
            {
                return false;
            }

            auto context = m_deviceResources->GetD3DDeviceContext();

            // Reset the viewport to target the whole screen.
            auto viewport = m_deviceResources->GetScreenViewport();
            context->RSSetViewports(1, &viewport);

            // Reset render targets to the screen.
            ID3D11RenderTargetView *const targets[1] = { m_deviceResources->GetBackBufferRenderTargetView() };
            context->OMSetRenderTargets(1, targets, m_deviceResources->GetDepthStencilView());

            // optional but common: clearing the framebuffer will be done in the app
            // context->ClearRenderTargetView(m_deviceResources->GetBackBufferRenderTargetView(), DirectX::Colors::CornflowerBlue);

            // Clear the depth stencil view.
            context->ClearDepthStencilView(m_deviceResources->GetDepthStencilView(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);


            // Render the scene objects:


            // set Cinder's pointers to the DX/D3D interfaces created here in the XAML framework
            shareWithCinder();

            // setup Cinder's shaders and lighting if needed
            if (!m_pipeline_ready) {
                ren->setupPipeline();
                m_pipeline_ready = true;
            }

            // setup Cinder's 3D camera and projection
            float w = m_deviceResources->GetOutputSize().Width;
            float h = m_deviceResources->GetOutputSize().Height;
            ren->setupCamera(w, h);

            // calls to overloaded Cinder app draw() method
            draw();

            // optional: display the frame rate
            // m_fpsTextRenderer->Render();

            return true;
        }

        void CinderMain::shareWithCinder()
        {
            // setup for Cinder::dx
            auto device = m_deviceResources->GetD3DDevice();
            auto features = m_deviceResources->GetDeviceFeatureLevel();
            auto context = m_deviceResources->GetD3DDeviceContext();
            auto viewport = m_deviceResources->GetScreenViewport();
            auto target = m_deviceResources->GetBackBufferRenderTargetView();
            auto stencil = m_deviceResources->GetDepthStencilView();

            ren->md3dDevice = device;
            ren->mFeatureLevel = features;
            ren->mDeviceContext = context;
            ren->mMainFramebuffer = target;
            ren->mDepthStencilView = stencil;
        }

        // Notifies renderers that device resources need to be released.
        void CinderMain::OnDeviceLost()
        {
            m_pipeline_ready = false;

            // optional: if using frame rate display, release it
            // m_fpsTextRenderer->ReleaseDeviceDependentResources();
        }

        // Notifies renderers that device resources may now be recreated.
        void CinderMain::OnDeviceRestored()
        {
            // optional: if using frame rate display, create it
            // m_fpsTextRenderer->CreateDeviceDependentResources();

            CreateWindowSizeDependentResources();
        }

        void CinderMain::TrackingUpdate(PointerEventArgs ^evtArgs)
        {
            if (!m_tracking) return;

            auto p = evtArgs->CurrentPoint->Position;
            int ix = p.X;
            int iy = p.Y;

            // create a Cinder mouse event
            // nb. refer to AppImplWinRT::prepPointerEventModifiers for a more complete implementation
            MouseEvent e(nullptr, 0, ix, iy, cinder::app::MouseEvent::LEFT_DOWN, 0, 0);

            // call the Cinder app mouse event handler
            mouseDrag(e);
        }

    }
} // end namespaces
