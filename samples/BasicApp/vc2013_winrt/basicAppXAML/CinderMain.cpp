// nb. this file was generated by the Window Store XAML template as DirectXPage, then modified for Cinder

#include "pch.h"
#include "CinderMain.h"
#include "Common\DirectXHelper.h"

#include "Common\StepTimer.h"
#include "Common\DeviceResources.h"

// zv
// #include "CinderBridge.h"

// zv
// extern BasicApp *app;	
// extern cinder::app::AppBasicXAML *app;


using namespace basicAppXAML;
using namespace Windows::Foundation;
using namespace Windows::System::Threading;
using namespace Concurrency;

namespace cinder {
    namespace app {

        // Loads and initializes application assets when the application is loaded.
        // zv7
        // CinderMain::CinderMain(const std::shared_ptr<DX::DeviceResources>& deviceResources) :
        //	m_deviceResources(deviceResources)

        void CinderMain::setup(const std::shared_ptr<DX::DeviceResources>& deviceResources)
        {
            m_deviceResources = deviceResources;

            // Register to be notified if the Device is lost or recreated
            // zv8
            /// m_deviceResources->RegisterDeviceNotify(this);
            // zv todo: handle this the old way, can't inherit from IDeviceNotify

            // TODO: Replace this with your app's content initialization.
            // m_sceneRenderer = std::unique_ptr<Sample3DSceneRenderer>(new Sample3DSceneRenderer(m_deviceResources));
            // zv deferred
            // m_sceneRenderer = std::unique_ptr<cinder::app::AppBasicXAML>(new cinder::app::AppBasicXAML(m_deviceResources));
            // m_sceneRenderer = reinterpret_cast<cinder::app::AppBasicXAML *>(app);
            // m_sceneRenderer = app;
            // m_sceneRenderer->m_deviceResources = deviceResources;

            // zv
            // m_fpsTextRenderer = std::unique_ptr<SampleFpsTextRenderer>(new SampleFpsTextRenderer(m_deviceResources));

            // TODO: Change the timer settings if you want something other than the default variable timestep mode.
            // e.g. for 60 FPS fixed timestep update logic, call:
            /*
            m_timer.SetFixedTimeStep(true);
            m_timer.SetTargetElapsedSeconds(1.0 / 60);
            */
            // zv7
            // std::unique_ptr<DX::StepTimer> m_timer;
            // m_timer = std::unique_ptr<DX::StepTimer>(new DX::StepTimer);
            m_timer = new DX::StepTimer;

            // create Cinder renderer for DirectX
            //  nb. Cinder will perform shader & lighting setup, and drawing via dx::
            //  initialization & device management is handled by the XAML framework

            // ren = std::shared_ptr<cinder::app::AppImplMswRendererDx>( new cinder::app::AppImplMswRendererDx( nullptr, nullptr ) );
            ren = new cinder::app::AppImplMswRendererDx(nullptr, nullptr);

        }

        CinderMain::~CinderMain()
        {
            // Deregister device notification
            m_deviceResources->RegisterDeviceNotify(nullptr);

            // zv
            // nb not currently a smart ptr
            // delete m_sceneRenderer;

            delete ren;
            delete m_timer;
        }

        // Updates application state when the window size changes (e.g. device orientation change)
        void CinderMain::CreateWindowSizeDependentResources()
        {
            // TODO: Replace this with the size-dependent initialization of your app's content.
            // m_sceneRenderer->CreateWindowSizeDependentResources();
        }

        void CinderMain::StartRenderLoop()
        {
            // If the animation render loop is already running then do not start another thread.
            if (m_renderLoopWorker != nullptr && m_renderLoopWorker->Status == AsyncStatus::Started)
            {
                return;
            }

            // Create a task that will be run on a background thread.
            auto workItemHandler = ref new WorkItemHandler([this](IAsyncAction ^ action)
            {
                // Calculate the updated frame and render once per vertical blanking interval.
                while (action->Status == AsyncStatus::Started)
                {
                    critical_section::scoped_lock lock(m_criticalSection);
                    Update();
                    if (Render())
                    {
                        m_deviceResources->Present();
                    }
                }
            });

            // Run task on a dedicated high priority background thread.
            m_renderLoopWorker = ThreadPool::RunAsync(workItemHandler, WorkItemPriority::High, WorkItemOptions::TimeSliced);
        }

        void CinderMain::StopRenderLoop()
        {
            m_renderLoopWorker->Cancel();
        }

        // Updates the application state once per frame.
        void CinderMain::Update()
        {
            ProcessInput();

            // Update scene objects.
            // zv7
            // m_timer.Tick([&]()           
            // nb. C++ 11 lambda function on instance of DX::StepTimer
            m_timer->Tick([&]()
            {
                // TODO: Replace this with your app's content update functions.
                // call to overloaded Cinder update()
                update();

                // zv
                // m_sceneRenderer->Update(m_timer);
                // m_fpsTextRenderer->Update(m_timer);
            });
        }

        // Process all input from the user before updating game state
        void CinderMain::ProcessInput()
        {
            // TODO: Add per frame input handling here.
            // zv
            // m_sceneRenderer->TrackingUpdate( mPtrX, mPtrY );
        }

        // Renders the current frame according to the current application state.
        // Returns true if the frame was rendered and is ready to be displayed.
        bool CinderMain::Render()
        {
            // Don't try to render anything before the first Update.
            // zv7
            // if (m_timer.GetFrameCount() == 0)
            if (m_timer->GetFrameCount() == 0)
            {
                return false;
            }

            auto context = m_deviceResources->GetD3DDeviceContext();

            // Reset the viewport to target the whole screen.
            auto viewport = m_deviceResources->GetScreenViewport();
            context->RSSetViewports(1, &viewport);

            // Reset render targets to the screen.
            ID3D11RenderTargetView *const targets[1] = { m_deviceResources->GetBackBufferRenderTargetView() };
            context->OMSetRenderTargets(1, targets, m_deviceResources->GetDepthStencilView());

            // zv
            // Clear the back buffer and depth stencil view.
            // this will be done (or not) in the app
            // context->ClearRenderTargetView(m_deviceResources->GetBackBufferRenderTargetView(), DirectX::Colors::CornflowerBlue);
            context->ClearDepthStencilView(m_deviceResources->GetDepthStencilView(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

            // Render the scene objects.
            // TODO: Replace this with your app's content rendering functions.
            // m_sceneRenderer->Render();

            // zv7
            shareWithCinder();

            if (!m_pipeline_ready) {
                ren->setupPipeline();
                m_pipeline_ready = true;
            }

            float w = m_deviceResources->GetOutputSize().Width;
            float h = m_deviceResources->GetOutputSize().Height;
            ren->setupCamera(w, h);

            // calls to overloaded Cinder method
            draw();

            // zv
            // m_fpsTextRenderer->Render();

            return true;
        }

        void CinderMain::shareWithCinder()
        {
            // setup for Cinder::dx
            auto device = m_deviceResources->GetD3DDevice();
            auto features = m_deviceResources->GetDeviceFeatureLevel();
            auto context = m_deviceResources->GetD3DDeviceContext();
            auto viewport = m_deviceResources->GetScreenViewport();
            auto target = m_deviceResources->GetBackBufferRenderTargetView();
            auto stencil = m_deviceResources->GetDepthStencilView();

            ren->md3dDevice = device;
            ren->mFeatureLevel = features;
            ren->mDeviceContext = context;
            ren->mMainFramebuffer = target;
            ren->mDepthStencilView = stencil;
        }

        // Notifies renderers that device resources need to be released.
        void CinderMain::OnDeviceLost()
        {
            //m_sceneRenderer->ReleaseDeviceDependentResources();

            // zv
            // m_fpsTextRenderer->ReleaseDeviceDependentResources();
        }

        // Notifies renderers that device resources may now be recreated.
        void CinderMain::OnDeviceRestored()
        {
            //m_sceneRenderer->CreateDeviceDependentResources();

            // zv
            // m_fpsTextRenderer->CreateDeviceDependentResources();

            CreateWindowSizeDependentResources();
        }

        void CinderMain::TrackingUpdate(PointerEventArgs ^evtArgs)
            // float x, float y)
        {
            // zv not needed?
            if (!m_tracking) return;

            // std::string s( evtArgs->ToString()->Data() );
            // OutputDebugString( evtArgs->ToString()->Data() );

            auto p = evtArgs->CurrentPoint->Position;
            int ix = p.X;
            int iy = p.Y;

            /*
            float w = m_deviceResources->GetOutputSize().Width;
            float h = m_deviceResources->GetOutputSize().Height;
            int ix = w == 0.0f ? 0 : evtArgs->CurrentPoint->Position.X / w;
            int iy = h == 0.0f ? 0 : evtArgs->CurrentPoint->Position.Y / h;
            */
            //int ix = x * m_deviceResources->GetOutputSize().Width;
            //int iy = y * m_deviceResources->GetOutputSize().Height;
            //int ix = 0;
            //int iy = 0;

            // zv temp
            //
            // MouseEvent ctor:
            // WindowRef win, int aInitiator, 
            // int aX, int aY, unsigned int aModifiers, 
            // float aWheelIncrement, uint32_t aNativeModifiers
            MouseEvent e(nullptr, 0, ix, iy, cinder::app::MouseEvent::LEFT_DOWN, 0, 0);

            // see AppImplWinRT::prepPointerEventModifiers

            mouseDrag(e);
        }

    }
} // end namespaces
